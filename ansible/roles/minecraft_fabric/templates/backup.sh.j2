#!/bin/sh
## back up the world, skipping if too many people are online

# {{ ansible_managed }}

#################
### FUNCTIONS ###
#################

# get nicely formatted timestamps
timestamp () {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

############
### VARS ###
############

BACKUP_DIR="$(dirname "$0")/backup/snapshots/survival"
BACKUP_TARGET="/home/minecraft/minecraft/services/survival/world"
MAX_BACKUPS=100
MAX_PLAYERS=3
PLAYERS_ONLINE="$(mcrcon -H 127.0.0.1 -P {{ survival_rcon_port }} -p {{ survival_rcon_pass }} list | cut -d' ' -f 3)"
MCRCON_ARGS="-H 127.0.0.1 -P {{ survival_rcon_port }} -p {{ survival_rcon_pass }}"

# start in script dir
cd "$(dirname "$0")"

printf "timestamp=$(timestamp) players_online=$PLAYERS_ONLINE\n"
printf 'timestamp=%s BACKUP_DIR="%s" MAX_BACKUPS=%i\n' "$(timestamp)" "$BACKUP_DIR" $MAX_BACKUPS
mkdir -p "$BACKUP_DIR"

# exit if there are too many players
if [ "$PLAYERS_ONLINE" -ge "$MAX_PLAYERS" ] ; then
  mcrcon "$MCRCON_ARGS" "server backup skipped: ${PLAYERS_ONLINE}/${MAX_PLAYERS} players on"
  printf 'timestamp=%s msg="%s"\n' "$(timestamp)" "too many players online, skipping backup!"
  exit 0
fi

mcrcon "$MCRCON_ARGS" "say server is backing up in 10 seconds... "
sleep 10

# backup world folders directly to current
#rsync -ravhz '{{ minecraft_dir }}/services/survival/world-survival' '{{ minecraft_dir }}/backup/current/world-survival'
rsync -ravhz '{{ minecraft_dir }}/services/survival-old/world-survival-old' '{{ minecraft_dir }}/backup/current/world-survival-old'
rsync -ravhz '{{ minecraft_dir }}/services/creative/world-creative' '{{ minecraft_dir }}/backup/current/world-creative'

# try to create the backup
create="$BACKUP_DIR/$(timestamp).tar.gz"
touch "$create"
tar \
  -czvf "$create" \
  --exclude="$BACKUP_TARGET/ledger.sqlite" \
  "$BACKUP_TARGET"

status=$?
printf 'timestamp=%s created="%s" status=%i\n' "$(timestamp)" "$create" $status

# tar normally exits nonzero if a file changes while the tarball is being created, in which case the backup will be corrupt.
#
# Here, we retry once more to get a non-corrupt tarball.
# In theory, we could get unlucky and end up with "smearing" if tar runs at just the wrong time to get individual elements
# from the world file with some before the backup and some after, but not happening in the middle of tar creation. This is
# probably unlikely.
# if [ $status -ne 0 ] ; then
#   status=$?
#   printf 'timestamp=%s created="%s" status=%i\n' "$(timestamp)" "$create" $status
# fi

# count backups
nbackups="$(ls -1 "$BACKUP_DIR" | grep ".tar.gz" | wc -l)"
printf 'timestamp=%s nbackups=%i\n' "$(timestamp)" $nbackups

# prune only if necessary
if [ $nbackups -gt $MAX_BACKUPS ] ; then
  printf 'timestamp=%s msg="begin backup rotation"\n' "$(timestamp)"
  while true ; do
    # loop to check if there are still too many, select the oldest if so, and then delete
    nbackups="$(ls -1 "$BACKUP_DIR"/*.tar.gz | wc -l)"
    if [ $nbackups -le $MAX_BACKUPS ] ; then
      printf 'timestamp=%s msg="rotation finished"\n' "$(timestamp)"
    fi

    oldest="$(ls -1 "$BACKUP_DIR"/*.tar.gz | sort | head -n1)"
    printf 'timestamp=%s prune="%s"\n' "$(timestamp)" "$oldest"
    rm -f "$oldest"
  done
fi

# healthcheck
if [ $status -eq 0 ] ; then
  curl --retry 5 \
    -L \
    -X POST \
    '{{ healthchecks_backup_url }}'
fi

exit 0
